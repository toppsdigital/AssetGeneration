'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { contentPipelineApi } from '../web/utils/contentPipelineApi';

interface PSDFile {
  name: string;
  lastModified: string | null;
  json_url?: string;
}

interface PSDTemplateSelectorProps {
  jobData: any;
  mergedJobData: any;
  isVisible: boolean;
  creatingAssets: boolean;
  setCreatingAssets: React.Dispatch<React.SetStateAction<boolean>>;
  onJobDataUpdate?: (updatedJobData: any) => void; // Callback to update parent component's job data
}

// For multiple spot/color selections in parallel mode
interface SpotColorPair {
  spot: string;
  color?: string;
}

interface AssetConfig {
  id: string;
  name: string; // User-editable name for the asset
  type: 'wp' | 'back' | 'base' | 'parallel' | 'multi-parallel' | 'wp-1of1';
  layer: string;
  spot?: string;
  color?: string;
  spotColorPairs?: SpotColorPair[]; // For PARALLEL cards with multiple combinations
  vfx?: string;
  chrome: string | boolean;
  oneOfOneWp?: boolean; // For BASE assets with superfractor chrome
  wp_inv_layer?: string; // For VFX and chrome effects
}

export const PSDTemplateSelector = ({ jobData, mergedJobData, isVisible, creatingAssets, setCreatingAssets, onJobDataUpdate }: PSDTemplateSelectorProps) => {
  const router = useRouter();
  
  // State management
  const [physicalJsonFiles, setPhysicalJsonFiles] = useState<PSDFile[]>([]);
  const [loadingPhysicalFiles, setLoadingPhysicalFiles] = useState(false);
  const [selectedPhysicalFile, setSelectedPhysicalFile] = useState<string>('');
  const [jsonData, setJsonData] = useState<any>(null);
  const [loadingJsonData, setLoadingJsonData] = useState(false);
  
  // New asset configuration state
  const [currentCardType, setCurrentCardType] = useState<'wp' | 'back' | 'base' | 'parallel' | 'multi-parallel' | 'wp-1of1' | null>(null);
  const [currentConfig, setCurrentConfig] = useState<Partial<AssetConfig>>({
    chrome: false,
    oneOfOneWp: false,
    name: '',
    wp_inv_layer: ''
  });
  const [editingAssetId, setEditingAssetId] = useState<string | null>(null);
  const [savingAsset, setSavingAsset] = useState(false);
  const [processingPdf, setProcessingPdf] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  
  const [spotColorPairs, setSpotColorPairs] = useState<SpotColorPair[]>([{ spot: '', color: undefined }]);

  // Fetch physical JSON files when component becomes visible
  useEffect(() => {
    if (isVisible) {
      fetchPhysicalJsonFiles();
    }
  }, [isVisible]);

  // Auto-select PSD file when only one option is available
  useEffect(() => {
    if (physicalJsonFiles.length === 1 && !selectedPhysicalFile && !loadingPhysicalFiles) {
      const singleFile = physicalJsonFiles[0].name;
      console.log('ðŸ”„ Auto-selecting single PSD file:', singleFile);
      setSelectedPhysicalFile(singleFile);
    }
  }, [physicalJsonFiles, selectedPhysicalFile, loadingPhysicalFiles]);

  // Download JSON when file is selected
  useEffect(() => {
    if (selectedPhysicalFile) {
      downloadJsonFile(selectedPhysicalFile);
    } else {
      setJsonData(null);
    }
    // Clear current configuration when changing files
    setCurrentConfig({ chrome: false });
    setCurrentCardType(null);
  }, [selectedPhysicalFile]);

  // Auto-update asset name when configuration changes
  useEffect(() => {
    if (currentCardType && !editingAssetId) {
      // Only auto-update if not editing an existing asset
      const existingNames = getConfiguredAssets().map(asset => asset.name);
      const configForName = {
        ...currentConfig,
        spotColorPairs: currentCardType === 'parallel' || currentCardType === 'multi-parallel' 
          ? spotColorPairs 
          : undefined
      };
      console.log('ðŸ” Name generation config:', { 
        cardType: currentCardType, 
        vfx: configForName.vfx, 
        chrome: configForName.chrome,
        spotColorPairs: configForName.spotColorPairs
      });
      const newName = generateAssetName(currentCardType, configForName, existingNames);
      
      // Only update if the name is empty or appears to be auto-generated (to preserve user edits)
      const basicPattern = generateAssetName(currentCardType, { type: currentCardType }, existingNames);
      const currentName = currentConfig.name || '';
      
      // Check if current name appears to be auto-generated by looking for patterns
      const isAutoGenerated = !currentName || 
                              currentName === basicPattern || 
                              currentName.endsWith('_1') || 
                              currentName.endsWith('_2') ||
                              currentName.startsWith(currentCardType === 'parallel' ? '' : currentCardType) ||
                              (currentCardType === 'parallel' && currentName.match(/^[a-z]+\d+$/)) ||  // matches pattern like "black1"
                              (currentCardType === 'multi-parallel' && currentName.match(/^[a-z]+\d+[a-z]+\d+/)); // matches pattern like "black1blue2"
      
      console.log('ðŸ” Name update check:', { 
        currentName, 
        newName, 
        basicPattern, 
        isAutoGenerated,
        shouldUpdate: isAutoGenerated 
      });
      
      if (isAutoGenerated) {
        console.log('ðŸ”„ Updating name from', currentName, 'to', newName);
        setCurrentConfig(prev => ({ ...prev, name: newName }));
      } else {
        console.log('ðŸš« Not updating name - appears to be user-edited');
      }
    }
  }, [currentCardType, currentConfig.layer, currentConfig.vfx, currentConfig.chrome, currentConfig.oneOfOneWp, spotColorPairs, editingAssetId]);

  // Auto-select wp_inv layer when VFX or chrome is enabled and only one wp_inv layer exists
  useEffect(() => {
    if (currentCardType && !editingAssetId) {
      const hasVfxOrChrome = currentConfig.vfx || currentConfig.chrome;
      const wpInvLayers = getWpInvLayers();
      
      if (hasVfxOrChrome && wpInvLayers.length === 1 && !currentConfig.wp_inv_layer) {
        setCurrentConfig(prev => ({ ...prev, wp_inv_layer: wpInvLayers[0] }));
      } else if (!hasVfxOrChrome && currentConfig.wp_inv_layer) {
        // Clear wp_inv_layer if VFX and chrome are both disabled
        setCurrentConfig(prev => ({ ...prev, wp_inv_layer: '' }));
      }
    }
  }, [currentCardType, currentConfig.vfx, currentConfig.chrome, editingAssetId]);

  // Debug mergedJobData changes
  useEffect(() => {
    console.log('ðŸ” mergedJobData changed in PSDTemplateSelector:', {
      timestamp: new Date().toISOString(),
      hasMergedJobData: !!mergedJobData,
      jobId: mergedJobData?.job_id,
      hasAssets: !!mergedJobData?.assets,
      assetsCount: mergedJobData?.assets ? Object.keys(mergedJobData.assets).length : 0,
      assetIds: mergedJobData?.assets ? Object.keys(mergedJobData.assets) : []
    });
  }, [mergedJobData]);

  const fetchPhysicalJsonFiles = async () => {
    try {
      setLoadingPhysicalFiles(true);
      
      console.log('ðŸ” Fetching physical JSON files from public endpoint...');
      
      const response = await fetch('/api/s3-proxy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          client_method: 'fetch_public_files',
          public_url: 'https://topps-nexus-powertools.s3.us-east-1.amazonaws.com/asset_generator/dev/public/digital_to_physical_psd_files.json',
          file_type: 'psd'
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch JSON files: ${response.status}`);
      }

      const data = await response.json();
      console.log('ðŸ“ Physical PSD files response:', data);
      
      const physicalFiles = (data.files || []).map((file: any) => ({
        name: file.file_name || file.name || '',
        lastModified: null,
        json_url: file.json_url
      }));
      
      console.log('ðŸŽ¯ Formatted physical JSON files:', physicalFiles);
      setPhysicalJsonFiles(physicalFiles);
      
    } catch (error) {
      console.error('âŒ Error fetching physical JSON files:', error);
    } finally {
      setLoadingPhysicalFiles(false);
    }
  };

  const downloadJsonFile = async (selectedFile: string) => {
    try {
      setLoadingJsonData(true);
      setJsonData(null);
      
      console.log('ðŸ” Downloading JSON via S3 proxy for selected file:', selectedFile);
      
      const selectedFileData = physicalJsonFiles.find(file => file.name === selectedFile);
      
      if (!selectedFileData || !selectedFileData.json_url) {
        throw new Error(`JSON URL not found for file: ${selectedFile}`);
      }
      
      const jsonUrl = selectedFileData.json_url;
      
      const requestBody = { 
        client_method: 'get',
        filename: jsonUrl,
        download: true,
        direct_url: jsonUrl.startsWith('http://') || jsonUrl.startsWith('https://')
      };
      
      const response = await fetch('/api/s3-proxy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        let errorDetails = `Status: ${response.status}`;
        try {
          const errorBody = await response.text();
          errorDetails += ` - ${errorBody}`;
        } catch (e) {
          console.log('âŒ Could not read error response body:', e);
        }
        throw new Error(`Failed to download JSON via proxy: ${errorDetails}`);
      }
      
      const jsonData = await response.json();
      console.log('ðŸ“‹ JSON data loaded successfully via proxy, keys:', Object.keys(jsonData || {}));
      
      if (jsonData && typeof jsonData === 'object') {
        setJsonData(jsonData);
      } else {
        throw new Error('Invalid JSON content received from proxy');
      }
      
    } catch (error) {
      console.error('âŒ Error downloading JSON via proxy:', error);
      setJsonData(null);
    } finally {
      setLoadingJsonData(false);
    }
  };

  const createAssets = async () => {
    if (!mergedJobData?.assets || Object.keys(mergedJobData.assets).length === 0) return;

    console.log('ðŸŽ¨ Creating digital assets with job assets:', {
      selectedFile: selectedPhysicalFile,
      psdFile: jsonData?.psd_file,
      jobAssets: mergedJobData.assets,
      totalAssets: Object.keys(mergedJobData.assets).length,
    });

    setCreatingAssets(true);

    try {
      const psdFile = selectedPhysicalFile.split('/').pop()?.replace('.json', '.psd') || '';
      
      // Convert job assets object to array format for API
      const assets = Object.values(mergedJobData.assets) as any[];

      const payload = {
        assets,
        psd_file: psdFile
      };

      console.log('ðŸ“‹ API Payload:', {
        ...payload,
        assetsCount: assets.length,
        assetsPreview: assets.map((asset: any) => ({ name: asset.name, type: asset.type }))
      });

      const response = await contentPipelineApi.generateAssets(jobData!.job_id!, payload);
      
      console.log('âœ… Assets creation response:', response);
      
      router.push('/jobs');
      
    } catch (error) {
      console.error('âŒ Error creating assets:', error);
      alert(`Failed to create assets: ${error instanceof Error ? error.message : 'Unknown error'}`);
      setCreatingAssets(false);
    }
  };

  const getExtractedLayers = () => {
    const extractedLayerNames = new Set<string>();
    
    const extractLayerName = (filename: string): string | null => {
      const nameWithoutExt = filename.replace(/\.(tif|pdf|png|jpg|jpeg)$/i, '');
      const parts = nameWithoutExt.split('_');
      
      if (parts.length < 3) return null;
      
      const layerParts = parts.slice(2);
      return layerParts.join('_');
    };
    
    if (mergedJobData?.content_pipeline_files) {
      mergedJobData.content_pipeline_files.forEach((fileGroup: any) => {
        if (fileGroup.extracted_files) {
          Object.keys(fileGroup.extracted_files).forEach(filename => {
            const layerName = extractLayerName(filename);
            if (layerName) {
              extractedLayerNames.add(layerName);
            }
          });
        }
      });
    }
    
    // Return all extracted layers without filtering
    const allLayers = Array.from(extractedLayerNames);
    
    console.log('ðŸ” Total extracted layers:', allLayers.length);
    
    return allLayers.sort();
  };

  // Hardcoded color mapping for consistent color selection
  const HARDCODED_COLORS = [
    { name: 'Aqua', rgb: 'R0G255B255' },
    { name: 'Black', rgb: 'R51G51B51' },
    { name: 'Blue', rgb: 'R0G102B204' },
    { name: 'Gold', rgb: 'R204G153B0' },
    { name: 'Green', rgb: 'R0G204B51' },
    { name: 'Magenta', rgb: 'R255G0B204' },
    { name: 'Orange', rgb: 'R255G102B0' },
    { name: 'Pink', rgb: 'R255G102B153' },
    { name: 'Purple', rgb: 'R153G51B255' },
    { name: 'Red', rgb: 'R255G0B0' },
    { name: 'Refractor', rgb: 'R153G153B153' },
    { name: 'Rose Gold', rgb: 'R255G102B102' },
    { name: 'Silver', rgb: 'R153G153B153' },
    { name: 'White', rgb: 'R255G255B255' },
    { name: 'Yellow', rgb: 'R255G255B0' }
  ];

  const getColorHexByName = (colorName: string): string => {
    const color = HARDCODED_COLORS.find(c => 
      c.name.toLowerCase() === colorName.toLowerCase()
    );
    // Convert RGB to hex for display (we can remove this function entirely if not needed)
    if (color?.rgb) {
      const rgbMatch = color.rgb.match(/R(\d+)G(\d+)B(\d+)/);
      if (rgbMatch) {
        const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
        const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
        const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
      }
    }
    return '#999999'; // Default gray for unknown colors
  };

  const getColorRgbByName = (colorName: string): string => {
    const color = HARDCODED_COLORS.find(c => 
      c.name.toLowerCase() === colorName.toLowerCase()
    );
    return color?.rgb || 'R153G153B153'; // Default gray for unknown colors
  };

  const getColorNameByRgb = (rgbValue: string): string => {
    const color = HARDCODED_COLORS.find(c => c.rgb === rgbValue);
    return color?.name || 'Unknown';
  };

  const getColorDisplayNameByRgb = (rgbValue: string): string => {
    const color = HARDCODED_COLORS.find(c => c.rgb === rgbValue);
    return color?.name || rgbValue;
  };

  const getColorHexByRgb = (rgbValue: string): string => {
    // Convert RGB string to hex for display
    const rgbMatch = rgbValue.match(/R(\d+)G(\d+)B(\d+)/);
    if (rgbMatch) {
      const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
      const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
      const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
      return `#${r}${g}${b}`;
    }
    return '#999999'; // Default gray for unknown colors
  };

  const getColorVariants = () => {
    // Return a single color group with all hardcoded colors
    return [{
      groupName: 'COLORS',
      colors: HARDCODED_COLORS
    }];
  };

  // Helper functions for new UI
  const getLayersByType = (type: 'wp' | 'back' | 'base' | 'parallel' | 'multi-parallel' | 'wp-1of1') => {
    const extractedLayers = getExtractedLayers();
    console.log('ðŸ” All extracted layers:', extractedLayers);
    
    const filtered = extractedLayers.filter(layer => {
      const lowerLayer = layer.toLowerCase();
      switch(type) {
        case 'wp':
        case 'wp-1of1':
          return lowerLayer.includes('wp') && !lowerLayer.includes('inv'); // Include wp but exclude wp_inv
        case 'back': 
          return lowerLayer.startsWith('bk') || lowerLayer.includes('back');
        case 'base':
          return lowerLayer.includes('fr_cmyk') || (lowerLayer.startsWith('fr') && lowerLayer.includes('cmyk'));
        case 'parallel':
        case 'multi-parallel':
          return lowerLayer.includes('spot') && (lowerLayer.startsWith('fr') || lowerLayer.includes('front'));
        default:
          return false;
      }
    });
    
    console.log(`ðŸŽ¯ Filtered ${type} layers:`, filtered);
    return filtered;
  };

  const getSpotLayers = () => {
  const extractedLayers = getExtractedLayers();
    return extractedLayers.filter(layer => 
      layer.toLowerCase().includes('spot')
    );
  };

  const getVfxTextures = () => {
    // Get VFX textures from JSON data under "VFX textures" group
    const vfxGroup = jsonData?.layers?.find((layer: any) => 
      layer.name?.toLowerCase().includes('vfx') || layer.name?.toLowerCase().includes('texture')
    );
    
    if (vfxGroup && vfxGroup.children) {
      return vfxGroup.children
        .map((child: any) => child.name || 'Unnamed Texture')
        .filter((textureName: string) => !textureName.toLowerCase().includes('wpcv')); // Filter out "wpcv"
    }
    return [];
  };

  const getWpInvLayers = () => {
    const extractedLayers = getExtractedLayers();
    return extractedLayers.filter(layer => 
      layer.toLowerCase().includes('wp') && layer.toLowerCase().includes('inv')
    );
  };

  // Helper function to get assets from job data
  const getConfiguredAssets = (): AssetConfig[] => {
    console.log('ðŸ” getConfiguredAssets called:', {
      timestamp: new Date().toISOString(),
      hasMergedJobData: !!mergedJobData,
      hasAssets: !!mergedJobData?.assets,
      assetsType: typeof mergedJobData?.assets,
      assetsKeys: mergedJobData?.assets ? Object.keys(mergedJobData.assets) : [],
      assetsCount: mergedJobData?.assets ? Object.keys(mergedJobData.assets).length : 0,
      mergedJobDataKeys: mergedJobData ? Object.keys(mergedJobData) : [],
      jobId: mergedJobData?.job_id
    });
    
    if (!mergedJobData?.assets) {
      console.log('âŒ No assets found in mergedJobData, returning empty array');
      return [];
    }
    
    const assets = Object.entries(mergedJobData.assets).map(([assetId, assetData]: [string, any]) => ({
      id: assetId,
      name: assetData.name || assetData.type?.toUpperCase() || 'UNNAMED',
      type: assetData.type || 'wp',
      layer: assetData.layer || '',
      spot: assetData.spot,
      color: assetData.color,
      spotColorPairs: assetData.spotColorPairs || assetData.spot_color_pairs || [],
      vfx: assetData.vfx,
      chrome: assetData.chrome || false,
      oneOfOneWp: assetData.oneOfOneWp || false,
      wp_inv_layer: assetData.wp_inv_layer || ''
    }));
    
    console.log('âœ… Parsed assets from mergedJobData.assets:', {
      count: assets.length,
      assetIds: assets.map(a => a.id),
      assetNames: assets.map(a => a.name),
      assetTypes: assets.map(a => a.type)
    });
    return assets;
  };

  const generateAssetName = (type: string, config: Partial<AssetConfig>, existingNames?: string[]): string => {
    let nameParts: string[] = [];
    
    // Start with simple lowercase type names
    if (type === 'wp' || type === 'wp-1of1') {
      nameParts.push('wp');
    } else if (type === 'back') {
      nameParts.push('back');
    } else if (type === 'base') {
      nameParts.push('base');
    } else if (type === 'parallel') {
      // For parallel, add color names with spot suffixes
      if (config.spotColorPairs && config.spotColorPairs.length > 0) {
        const colorParts = config.spotColorPairs
          .filter(pair => pair.spot && pair.color)
          .map((pair, index) => {
            const colorName = pair.color?.toLowerCase() || '';
            // Extract spot number from spot name (like spot1 -> 1, or use auto)
            const spotMatch = pair.spot?.match(/spot(\d+)/i);
            const spotSuffix = spotMatch ? spotMatch[1] : 'auto';
            return `${colorName}${spotSuffix}`;
          });
        
        if (colorParts.length > 0) {
          nameParts.push(...colorParts);
        } else {
          nameParts.push('parallel');
        }
      } else {
        nameParts.push('parallel');
      }
      
      // Add VFX for parallel if present
      if (config.vfx) {
        const cleanVfx = config.vfx.toLowerCase().replace(/[^a-zA-Z0-9]/g, '');
        console.log('ðŸ” Adding VFX to parallel name:', config.vfx, 'â†’', cleanVfx);
        nameParts.push(cleanVfx);
      }
    } else if (type === 'multi-parallel') {
      // For multi-parallel, add color names with spot suffixes
      if (config.spotColorPairs && config.spotColorPairs.length > 0) {
        const colorParts = config.spotColorPairs
          .filter(pair => pair.spot && pair.color)
          .map((pair, index) => {
            const colorName = pair.color?.toLowerCase() || '';
            // Extract spot number from spot name (like spot1 -> 1, or use auto)
            const spotMatch = pair.spot?.match(/spot(\d+)/i);
            const spotSuffix = spotMatch ? spotMatch[1] : 'auto';
            return `${colorName}${spotSuffix}`;
          });
        
        if (colorParts.length > 0) {
          nameParts.push(...colorParts);
        } else {
          nameParts.push('multiparallel');
        }
      } else {
        nameParts.push('multiparallel');
      }
      
      // Add VFX for multi-parallel if present
      if (config.vfx) {
        const cleanVfx = config.vfx.toLowerCase().replace(/[^a-zA-Z0-9]/g, '');
        console.log('ðŸ” Adding VFX to multi-parallel name:', config.vfx, 'â†’', cleanVfx);
        nameParts.push(cleanVfx);
      }
    }
    
    // Add VFX for base card type if present
    if (type === 'base' && config.vfx) {
      const cleanVfx = config.vfx.toLowerCase().replace(/[^a-zA-Z0-9]/g, '');
      nameParts.push(cleanVfx);
    }
    
    // Add chrome info - only include superfractor in name
    if (config.chrome && config.chrome === 'superfractor') {
      console.log('ðŸ” Adding superfractor to name:', config.chrome);
      nameParts.push('superfractor');
    }
    

    // Note: oneOfOneWp only controls creation of separate wp-1of1 asset, not the base asset name
    
    // Join with underscores
    console.log('ðŸ” Final name parts before joining:', nameParts);
    let baseName = nameParts.join('_');
    console.log('ðŸ” Generated base name:', baseName);
    
    // Check for duplicates and add number suffix if needed
    if (existingNames && existingNames.length > 0) {
      let finalName = baseName;
      let counter = 1;
      
      while (existingNames.some(name => name.toLowerCase() === finalName.toLowerCase())) {
        finalName = `${baseName}_${counter}`;
        counter++;
      }
      
      return finalName;
    }
    
    return baseName;
  };

  const resetCurrentConfig = () => {
    setCurrentConfig({ chrome: false, oneOfOneWp: false, name: '', wp_inv_layer: '' });
    setCurrentCardType(null);
    setEditingAssetId(null);
    setSpotColorPairs([{ spot: '', color: undefined }]);
  };

  const addAsset = async () => {
    if (!currentCardType || !jobData?.job_id || savingAsset) return;
    
    setSavingAsset(true);
    
    try {
      // Build asset configuration
      let assetConfig: any = {
        type: currentCardType
      };
      
      // Only include chrome if it has a value
      if (currentConfig.chrome) {
        assetConfig.chrome = currentConfig.chrome;
      }



      // Handle parallel/multi-parallel with multiple spot/color pairs
      if (currentCardType === 'parallel' || currentCardType === 'multi-parallel') {
        const validPairs = spotColorPairs.filter(pair => pair.spot && pair.color);
        if (validPairs.length === 0) return;
        
        assetConfig = {
          ...assetConfig,
          spot_color_pairs: validPairs.map(pair => ({
            spot: pair.spot,
            color: getColorRgbByName(pair.color || '')
          })),
          vfx: currentConfig.vfx
        };

        // Include wp_inv_layer if VFX or chrome is enabled
        if ((currentConfig.vfx || currentConfig.chrome) && currentConfig.wp_inv_layer) {
          assetConfig.wp_inv_layer = currentConfig.wp_inv_layer;
        }
      } else {
        // Handle other card types
        if (!currentConfig.layer) return;
        
        assetConfig = {
          ...assetConfig,
          layer: currentConfig.layer,
          spot: currentConfig.spot,
          color: currentConfig.color ? getColorRgbByName(currentConfig.color) : undefined,
          vfx: currentConfig.vfx
        };

        // Include wp_inv_layer if VFX or chrome is enabled
        if ((currentConfig.vfx || currentConfig.chrome) && currentConfig.wp_inv_layer) {
          assetConfig.wp_inv_layer = currentConfig.wp_inv_layer;
        }
      }

      // Asset payload with name and configuration - backend will generate ID
      const assetPayload = {
        ...assetConfig,
        name: currentConfig.name?.trim()
      };

      let response;
      if (editingAssetId) {
        // Update existing asset
        response = await contentPipelineApi.updateAsset(jobData.job_id, editingAssetId, assetPayload);
      } else {
        // Create new asset - backend will generate ID and store this config
        response = await contentPipelineApi.createAsset(jobData.job_id, assetPayload);
        
        // If creating a new BASE asset with superfractor chrome, also create a wp-1of1 version
        if (response.success && currentCardType === 'base' && currentConfig.chrome === 'superfractor' && currentConfig.oneOfOneWp) {
          console.log('ðŸŽ¯ Creating additional wp-1of1 asset for BASE + superfractor...');
          
          // Get WP layers for the wp-1of1 asset
          const wpLayers = getLayersByType('wp');
          if (wpLayers.length > 0) {
            const wp1of1Payload = {
              type: 'wp-1of1',
              layer: wpLayers[0], // Use first available WP layer - no VFX or chrome like regular wp
              name: `${currentConfig.name?.trim()}_WP_1OF1`
            };
            
            try {
              const wp1of1Response = await contentPipelineApi.createAsset(jobData.job_id, wp1of1Payload);
              console.log('âœ… wp-1of1 asset created for BASE + superfractor:', wp1of1Response);
            } catch (wp1of1Error) {
              console.error('âŒ Error creating wp-1of1 asset:', wp1of1Error);
              // Don't fail the main asset creation if wp-1of1 fails
            }
          }
        }
      }

      if (response.success) {
        console.log('âœ… Asset saved successfully:', {
          success: response.success,
          hasJob: !!response.job,
          jobAssets: response.job?.assets ? Object.keys(response.job.assets) : 'no job data returned',
          fullResponse: response
        });
        
        if (response.job && onJobDataUpdate) {
          console.log('ðŸ”„ Calling onJobDataUpdate with job data from response');
          onJobDataUpdate(response.job);
        } else if (onJobDataUpdate) {
          console.log('ðŸ”„ No job data in response, triggering refetch to get updated asset list');
          // Asset created successfully but no job data returned - trigger a refetch
          // We'll pass a special signal to force a refetch
          onJobDataUpdate({ _forceRefetch: true, job_id: jobData.job_id });
        }
      } else {
        console.log('âŒ Asset creation failed:', {
          success: response.success,
          hasJob: !!response.job,
          hasCallback: !!onJobDataUpdate,
          response: response
        });
      }
      
      resetCurrentConfig();
    } catch (error) {
      console.error('âŒ Error saving asset:', error);
      alert(`Failed to save asset: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setSavingAsset(false);
    }
  };



  const removeAsset = async (id: string) => {
    if (!jobData?.job_id || savingAsset) return;
    
    setSavingAsset(true);
    
    try {
      console.log('ðŸ—‘ï¸ Removing asset:', id);
      const response = await contentPipelineApi.deleteAsset(jobData.job_id, id);
      
      if (response.success) {
        console.log('âœ… Asset removed successfully:', {
          success: response.success,
          hasJob: !!response.job,
          fullResponse: response
        });
        
        if (response.job && onJobDataUpdate) {
          console.log('ðŸ”„ Calling onJobDataUpdate with job data from delete response');
          onJobDataUpdate(response.job);
        } else if (onJobDataUpdate) {
          console.log('ðŸ”„ No job data in delete response, triggering refetch to get updated asset list');
          // Asset deleted successfully but no job data returned - trigger a refetch
          onJobDataUpdate({ _forceRefetch: true, job_id: jobData.job_id });
        }
      } else {
        console.log('âŒ Asset deletion failed:', {
          success: response.success,
          response: response
        });
      }
    } catch (error) {
      console.error('âŒ Error removing asset:', error);
      alert(`Failed to remove asset: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setSavingAsset(false);
    }
  };

  const editAsset = (asset: AssetConfig) => {
    setCurrentCardType(asset.type);
    
    // Convert RGB values back to color names for UI form
    const convertedAsset = {
      ...asset,
      color: asset.color?.startsWith('R') ? getColorNameByRgb(asset.color) : asset.color
    };
    setCurrentConfig(convertedAsset);
    setEditingAssetId(asset.id);
    
    // For parallel assets, populate the spot/color pairs
    if (asset.type === 'parallel' || asset.type === 'multi-parallel') {
      if (asset.spotColorPairs && asset.spotColorPairs.length > 0) {
        // New format with multiple pairs - convert RGB values to color names for UI
        const convertedPairs = asset.spotColorPairs.map(pair => ({
          spot: pair.spot,
          color: pair.color?.startsWith('R') ? getColorNameByRgb(pair.color) : pair.color
        }));
        setSpotColorPairs(convertedPairs);
      } else if (asset.spot && asset.color) {
        // Legacy format with single spot/color
        setSpotColorPairs([{
          spot: asset.spot,
          color: asset.color?.startsWith('R') ? getColorNameByRgb(asset.color) : asset.color
        }]);
      }
      // Clear spot/color from current config since it's in the pairs
      setCurrentConfig(prev => ({ ...prev, spot: undefined, color: undefined }));
    }
  };

  const handleEDRPdfUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    console.log('ðŸ“‹ EDR PDF Upload initiated:', file.name, 'Size:', (file.size / 1024 / 1024).toFixed(2), 'MB');
    
    const fileSizeMB = file.size / (1024 * 1024);
    
    setProcessingPdf(true);
    setUploadProgress(0);

    try {
      // Always use streaming approach (base64 no longer supported)
      console.log('ðŸ“‹ Using streaming upload approach for all files');
      await handleAllFileUpload(file, fileSizeMB);
    } catch (error) {
      console.error('âŒ Error uploading EDR PDF:', error);
      alert(`Failed to process PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setProcessingPdf(false);
      setUploadProgress(0);
    }

    // Clear the input value so the same file can be selected again
    event.target.value = '';
  };

  // Handle large file uploads using streaming S3 API
  const handleLargeFileUpload = async (file: File, fileSizeMB: number) => {
    // Step 1: Get upload instructions using the new streaming S3 API
    console.log('ðŸ“‹ Step 1: Getting S3 upload instructions...');
    
    const timestamp = Date.now();
    const s3FileName = `${timestamp}_${file.name}`;
    const s3FolderPath = 'asset_generator/dev/edr_uploads';
      
      // Use the new streaming upload API format
      const uploadInstructionsResponse = await fetch('/api/content-pipeline-proxy?operation=s3_upload_files', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          folder: s3FolderPath,
          files: [{
            filename: s3FileName,
            size: file.size,
            content_type: file.type || 'application/pdf'
          }]
        }),
      });

      if (!uploadInstructionsResponse.ok) {
        const errorData = await uploadInstructionsResponse.json().catch(() => ({}));
        throw new Error(`Failed to get upload instructions: ${uploadInstructionsResponse.status} ${JSON.stringify(errorData)}`);
      }

      const instructionsResult = await uploadInstructionsResponse.json();
      console.log('âœ… Got upload instructions:', instructionsResult);
      setUploadProgress(10);

      const uploadInstruction = instructionsResult.data.upload_instructions[0];
      const s3Key = uploadInstruction.s3_key; // Use the exact s3_key returned from upload instructions

      // Step 2: Upload file using the provided instructions
      console.log('ðŸ“‹ Step 2: Uploading file using instructions...');
      
      let uploadResponse;
      
      if (uploadInstruction.upload_type === 'single') {
        // Single upload for smaller files (< 100MB)
        console.log('ðŸ“‹ Using single upload method');
        
        const formData = new FormData();
        
        // Add all the required fields from the upload instructions
        Object.entries(uploadInstruction.upload_data.fields).forEach(([key, value]) => {
          formData.append(key, value as string);
        });
        
        // Add the file last (important for S3)
        formData.append('file', file);
        
        uploadResponse = await fetch(uploadInstruction.upload_data.url, {
          method: uploadInstruction.upload_data.method,
          body: formData,
        });
        
        setUploadProgress(90); // Single upload completed
        
      } else if (uploadInstruction.upload_type === 'multipart') {
        // Multipart upload for larger files (> 100MB)
        console.log('ðŸ“‹ Using multipart upload method');
        
        const partETags = [];
        const partSize = uploadInstruction.upload_data.part_size;
        
        // Upload each part with progress tracking
        const totalParts = uploadInstruction.upload_data.part_urls.length;
        for (let i = 0; i < uploadInstruction.upload_data.part_urls.length; i++) {
          const partInfo = uploadInstruction.upload_data.part_urls[i];
          const start = partInfo.size_range.start;
          const end = Math.min(partInfo.size_range.end + 1, file.size);
          const chunk = file.slice(start, end);
          
          console.log(`ðŸ“‹ Uploading part ${partInfo.part_number} (${start}-${end})`);
          
          const partResponse = await fetch(partInfo.url, {
            method: 'PUT',
            body: chunk,
          });
          
          if (!partResponse.ok) {
            throw new Error(`Part ${partInfo.part_number} upload failed: ${partResponse.status}`);
          }
          
          const etag = partResponse.headers.get('ETag');
          partETags.push({
            PartNumber: partInfo.part_number,
            ETag: etag
          });
          
          // Update progress (10% for getting instructions, 80% for upload, 10% for processing)
          const partProgress = ((i + 1) / totalParts) * 80;
          setUploadProgress(10 + partProgress);
        }
        
        // Complete the multipart upload
        console.log('ðŸ“‹ Completing multipart upload...');
        
        const completeXML = `<?xml version="1.0" encoding="UTF-8"?>
<CompleteMultipartUpload>
${partETags.map(part => `  <Part><PartNumber>${part.PartNumber}</PartNumber><ETag>${part.ETag}</ETag></Part>`).join('\n')}
</CompleteMultipartUpload>`;
        
        uploadResponse = await fetch(uploadInstruction.upload_data.complete_url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/xml',
          },
          body: completeXML,
        });
      }

      if (!uploadResponse.ok) {
        const errorText = await uploadResponse.text();
        throw new Error(`S3 upload failed: ${uploadResponse.status} ${errorText}`);
      }

      console.log('âœ… PDF uploaded to S3 successfully:', s3Key);
      setUploadProgress(95);

      // Step 3: Process the uploaded file via Content Pipeline using S3 key
      console.log('ðŸ“‹ Step 3: Calling Content Pipeline for PDF extraction...');
      
      // Get extracted layers to include in the request
      const allExtractedLayers = getExtractedLayers();
      
      // Filter out specific layer types that shouldn't be sent to PDF extraction
      const filteredLayers = allExtractedLayers.filter(layer => {
        const lowerLayer = layer.toLowerCase();
        return !lowerLayer.includes('bk_seq') && 
               !lowerLayer.includes('bk_seq_bb');
      });
      
      // Prepare API request with S3 key (exact key from upload response)
      const requestPayload = {
        s3_key: s3Key,  // Use the exact s3_key returned from upload instructions
        filename: file.name,       // Original filename for reference
        layers: filteredLayers.length > 0 ? filteredLayers : undefined,
        job_id: jobData?.job_id
      };

      console.log('ðŸ“‹ Calling content pipeline API /pdf-extract:', {
        originalFilename: file.name,
        s3Key: s3Key,
        jobId: jobData?.job_id,
        fileSizeMB: (file.size / 1024 / 1024).toFixed(2),
        totalLayersFound: allExtractedLayers.length,
        filteredLayersCount: filteredLayers.length,
        filteredLayers: filteredLayers,
        excludedLayers: allExtractedLayers.filter(layer => !filteredLayers.includes(layer))
      });

      // Call the content pipeline API (small payload, just metadata)
      const response = await contentPipelineApi.extractPdfData(requestPayload);

      console.log('âœ… PDF Extract API Response:', response);
      console.log('ðŸ“‹ Full JSON Response:', JSON.stringify(response, null, 2));

      // Debug the response structure and compare to addAsset
      console.log('ðŸ” EDR Response Debug:', {
        hasSuccess: 'success' in response,
        successValue: response.success,
        hasJob: 'job' in response,
        jobExists: !!response.job,
        jobAssetsCount: response.job?.assets ? Object.keys(response.job.assets).length : 0,
        jobAssetIds: response.job?.assets ? Object.keys(response.job.assets) : [],
        hasOnJobDataUpdate: !!onJobDataUpdate,
        responseKeys: Object.keys(response)
      });

      // Update job data if response contains job object
      // Note: EDR response has job directly, not response.success like createAsset
      if (response.job && onJobDataUpdate) {
        console.log('ðŸ”„ Updating job data from EDR PDF import response (found job object)');
        onJobDataUpdate(response.job);
      } else if (response.success && response.job && onJobDataUpdate) {
        console.log('ðŸ”„ Updating job data from EDR PDF import response (success + job)');
        onJobDataUpdate(response.job);
      } else if (onJobDataUpdate) {
        console.log('ðŸ”„ No job data in EDR response, triggering refetch to get updated job data');
        // PDF processed successfully but no job data returned - trigger a refetch
        onJobDataUpdate({ _forceRefetch: true, job_id: jobData?.job_id });
      } else {
        console.log('âŒ Could not update job data - missing onJobDataUpdate callback');
      }
  };

  // Handle all file uploads using direct S3 proxy approach (bypasses Vercel limits)
  const handleAllFileUpload = async (file: File, fileSizeMB: number) => {
    console.log('ðŸ“‹ Starting direct S3 proxy upload for EDR PDF...');
    
    const s3FileName = file.name;
    const appName = jobData?.app_name || 'default_app';
    const presignedPath = `${appName}/EDR/${s3FileName}`;  // For presigned URL
    
    setUploadProgress(10);

    // Step 1: Get presigned PUT URL from our S3 proxy
    console.log('ðŸ“‹ Step 1: Getting presigned PUT URL...');
    
    const putUrlResponse = await fetch('/api/s3-proxy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        client_method: 'put',
        filename: presignedPath,
        expires_in: 3600
      }),
    });

    if (!putUrlResponse.ok) {
      throw new Error('Failed to get PUT presigned URL for EDR upload');
    }

    const { url: putUrl } = await putUrlResponse.json();
    
    // Extract S3 key from the presigned URL for the extract API
    const urlObj = new URL(putUrl);
    const s3PathFromUrl = urlObj.pathname.substring(1); // Remove leading slash and query params are automatically excluded
    const extractApiS3Key = s3PathFromUrl; // Clean S3 key without query parameters
    
    console.log('ðŸ“‹ Extracted S3 key from presigned URL:', extractApiS3Key);
    setUploadProgress(30);

    // Step 2: Upload file via our S3 proxy (bypasses Vercel payload limits and CORS)
    console.log('ðŸ“‹ Step 2: Uploading file via S3 proxy...');
    
    const uploadResponse = await fetch('/api/s3-upload', {
      method: 'PUT',
      headers: {
        'Content-Type': file.type || 'application/pdf',
        'x-presigned-url': putUrl,
      },
      body: file,
    });

    if (!uploadResponse.ok) {
      const errorText = await uploadResponse.text();
      throw new Error(`S3 upload failed: ${uploadResponse.status} ${errorText}`);
    }

    console.log('âœ… PDF uploaded to S3 successfully:', extractApiS3Key);
    setUploadProgress(85);

    // Step 3: Process the PDF via Content Pipeline using S3 key
    console.log('ðŸ“‹ Step 3: Calling Content Pipeline for PDF extraction...');
    
    // Get extracted layers to include in the request
    const allExtractedLayers = getExtractedLayers();
    
    // Filter out specific layer types that shouldn't be sent to PDF extraction
    const filteredLayers = allExtractedLayers.filter(layer => {
      const lowerLayer = layer.toLowerCase();
      return !lowerLayer.includes('bk_seq') && 
             !lowerLayer.includes('bk_seq_bb');
    });
    
    // Prepare API request with full S3 key for extract API
    const requestPayload = {
      s3_key: extractApiS3Key,  // Use full S3 key for extract API
      filename: file.name,
      layers: filteredLayers.length > 0 ? filteredLayers : undefined,
      job_id: jobData?.job_id
    };

    console.log('ðŸ“‹ Calling content pipeline API /pdf-extract:', {
      filename: file.name,
      jobId: jobData?.job_id,
      s3Key: extractApiS3Key,
      fileSizeMB: fileSizeMB.toFixed(2),
      totalLayersFound: allExtractedLayers.length,
      filteredLayersCount: filteredLayers.length,
      filteredLayers: filteredLayers,
      excludedLayers: allExtractedLayers.filter(layer => !filteredLayers.includes(layer))
    });

    setUploadProgress(90);

    // Call the content pipeline API with S3 key
    const response = await contentPipelineApi.extractPdfData(requestPayload);
    
    console.log('âœ… PDF Extract API Response:', response);
    console.log('ðŸ“‹ Full JSON Response:', JSON.stringify(response, null, 2));

    setUploadProgress(95);

    // Update job data if response contains job object
    if (response.job && onJobDataUpdate) {
      console.log('ðŸ”„ Updating job data from EDR PDF import response (found job object)');
      onJobDataUpdate(response.job);
    } else if (response.success && response.job && onJobDataUpdate) {
      console.log('ðŸ”„ Updating job data from EDR PDF import response (success + job)');
      onJobDataUpdate(response.job);
    } else if (onJobDataUpdate) {
      console.log('ðŸ”„ No job data in EDR response, triggering refetch to get updated job data');
      onJobDataUpdate({ _forceRefetch: true, job_id: jobData?.job_id });
    } else {
      console.log('âŒ Could not update job data - missing onJobDataUpdate callback');
    }
  };

  if (!isVisible) return null;

  const extractedLayers = getExtractedLayers();
  const colorVariants = getColorVariants();
  const configuredAssets = getConfiguredAssets();
  const canCreateAssets = configuredAssets.length > 0;

  // Debug when component re-renders due to asset changes
  console.log('ðŸ” PSDTemplateSelector render:', {
    configuredAssetsCount: configuredAssets.length,
    configuredAssetIds: configuredAssets.map(a => a.id),
    timestamp: new Date().toISOString()
  });

  return (
    <>
      <div style={{
        background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(147, 51, 234, 0.15))',
        border: '2px solid rgba(59, 130, 246, 0.3)',
        borderRadius: 16,
        padding: 24,
        marginBottom: 32,
        position: 'relative',
        overflow: 'hidden'
      }}>
        {/* Header */}
        <div style={{
          display: 'flex',
          alignItems: 'center',
          gap: 16,
          marginBottom: 16
        }}>
          <div style={{
            width: 48,
            height: 48,
            borderRadius: '50%',
            background: 'linear-gradient(135deg, #3b82f6, #8b5cf6)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: 24,
            flexShrink: 0
          }}>
            {mergedJobData?.job_status?.toLowerCase() === 'generation-failed' ? 'ðŸ”„' : 'âš¡'}
          </div>
          <div>
            <h2 style={{
              fontSize: '1.4rem',
              fontWeight: 700,
              color: '#f8f8f8',
              margin: '0 0 8px 0'
            }}>
              âš¡ {mergedJobData?.job_status?.toLowerCase() === 'generation-failed' ? 'Retry Asset Generation' : 'Action Required: Configure Digital Assets'}
            </h2>
            <p style={{
              fontSize: '1rem',
              color: '#bfdbfe',
              margin: 0,
              lineHeight: 1.5
            }}>
              {mergedJobData?.job_status?.toLowerCase() === 'generation-failed' 
                ? 'Asset generation failed. Review and modify your configuration below, then retry generation.'
                : 'Configure your digital assets by selecting a PSD template and configuring card types, layers, and colors below.'
              }
            </p>
          </div>
        </div>

        {/* Configuration Sections */}
        <div style={{ display: 'flex', flexDirection: 'column', gap: 20 }}>
          {/* PSD File Selection */}
          <div style={{ display: 'flex', alignItems: 'center', gap: 16, marginBottom: 20 }}>
            <label style={{
              fontSize: 16,
              fontWeight: 600,
              color: '#f8f8f8',
              minWidth: 120
            }}>
              Select PSD:
            </label>
            {loadingPhysicalFiles ? (
              <div style={{
                flex: 1,
                maxWidth: 400,
                padding: '12px 16px',
                background: 'rgba(255, 255, 255, 0.08)',
                border: '1px solid rgba(255, 255, 255, 0.2)',
                borderRadius: 8,
                display: 'flex',
                alignItems: 'center',
                gap: 8
              }}>
                <div style={{
                  width: 16,
                  height: 16,
                  border: '2px solid rgba(255, 255, 255, 0.3)',
                  borderTop: '2px solid #60a5fa',
                  borderRadius: '50%',
                  animation: 'spin 1s linear infinite'
                }} />
                <span style={{ color: '#9ca3af', fontSize: 14 }}>
                  Loading PSD templates...
                </span>
              </div>
            ) : (
              <select
                value={selectedPhysicalFile}
                onChange={(e) => setSelectedPhysicalFile(e.target.value)}
                disabled={loadingPhysicalFiles}
                style={{
                  flex: 1,
                  maxWidth: 400,
                  padding: '12px 16px',
                  background: 'rgba(255, 255, 255, 0.08)',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  borderRadius: 8,
                  color: '#f8f8f8',
                  fontSize: 14,
                  outline: 'none',
                  transition: 'border-color 0.2s',
                  boxSizing: 'border-box'
                }}
              >
                <option value="" style={{ background: '#1f2937', color: '#f8f8f8' }}>
                  {physicalJsonFiles.length === 1 ? 'Auto-selected PSD file...' : 'Select PSD file...'}
                </option>
                {physicalJsonFiles.map((file, index) => {
                  const filename = file.name.split('/').pop() || file.name;
                  const displayName = filename.replace('.json', '');
                  return (
                    <option 
                      key={index} 
                      value={file.name} 
                      style={{ background: '#1f2937', color: '#f8f8f8' }}
                    >
                      {displayName}
                    </option>
                  );
                })}
              </select>
            )}
          </div>

          {/* Loading JSON Data */}
          {selectedPhysicalFile && loadingJsonData && (
            <div style={{
              padding: '24px',
              textAlign: 'center',
              background: 'rgba(255, 255, 255, 0.05)',
              borderRadius: 12,
              border: '1px solid rgba(255, 255, 255, 0.1)',
              margin: '20px 0'
            }}>
              <div style={{
                width: 32,
                height: 32,
                border: '3px solid rgba(59, 130, 246, 0.3)',
                borderTop: '3px solid #3b82f6',
                borderRadius: '50%',
                animation: 'spin 1s linear infinite',
                margin: '0 auto 16px'
              }} />
              <div style={{
                color: '#9ca3af',
                fontSize: 14,
                marginBottom: 8
              }}>
                Loading PSD template data...
              </div>
            </div>
          )}

          {/* New Asset Builder UI */}
          {selectedPhysicalFile && jsonData && !loadingJsonData && (
            <div style={{ display: 'flex', gap: 24, alignItems: 'flex-start' }}>
              {/* Left Side: Asset Configuration Panel */}
              <div style={{
                flex: '0 0 300px',
                minWidth: 280,
                maxWidth: 300,
                background: 'rgba(255, 255, 255, 0.05)',
                borderRadius: 12,
                border: '1px solid rgba(255, 255, 255, 0.1)',
                padding: 16
              }}>
                <h3 style={{
                  fontSize: 18,
                  fontWeight: 600,
                  color: '#f8f8f8',
                  margin: '0 0 16px 0'
                }}>
                  Select Card Type
                </h3>
                
                {/* Step 1: Card Type Selection */}
                <div style={{ marginBottom: 16 }}>
                  <div style={{ display: 'flex', gap: 12, flexWrap: 'wrap' }}>
                    {(['wp', 'back', 'base', 'parallel', 'multi-parallel'] as const)
                      .filter(type => {
                        // Hide multi-parallel if there's only 1 spot layer
                        if (type === 'multi-parallel') {
                          return getSpotLayers().length > 1;
                        }
                        return true;
                      })
                      .map(type => (
                      <button
                        key={type}
                        onClick={() => {
                          setCurrentCardType(type);
                          
                          // Get existing asset names to avoid duplicates
                          const existingNames = getConfiguredAssets().map(asset => asset.name);
                          
                          if (type === 'parallel' || type === 'multi-parallel') {
                            // For parallel/multi-parallel, initialize with one empty pair
                            setSpotColorPairs([{ spot: '', color: undefined }]);
                            const initialConfig = { 
                              chrome: false,
                              type,
                              spot: '',
                              layer: '',
                              name: generateAssetName(type, { type }, existingNames)
                            };
                            setCurrentConfig(initialConfig);
                          } else {
                            // For other types, clear spot/color pairs
                            setSpotColorPairs([]);
                            const layersForType = getLayersByType(type);
                            const autoSelectedLayer = layersForType.length === 1 ? layersForType[0] : '';
                            const initialConfig = { 
                              chrome: false,
                              oneOfOneWp: false,
                              type,
                              layer: autoSelectedLayer,
                              name: ''
                            };
                            initialConfig.name = generateAssetName(type, initialConfig, existingNames);
                            setCurrentConfig(initialConfig);
                          }
                        }}
                        style={{
                          padding: '8px 16px',
                          background: currentCardType === type ? '#3b82f6' : 'rgba(255, 255, 255, 0.1)',
                          border: '1px solid rgba(255, 255, 255, 0.2)',
                          borderRadius: 8,
                          color: '#f8f8f8',
                          fontSize: 14,
                          cursor: 'pointer',
                          transition: 'all 0.2s'
                        }}
                      >
                        {type === 'base' ? 'BASE' : type === 'parallel' ? 'PARALLEL' : type === 'multi-parallel' ? 'MULTI-PARALLEL' : type.toUpperCase()}
                      </button>
                    ))}
                  </div>
                </div>

                {/* Dynamic Configuration based on Card Type */}
                {currentCardType && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
                    {/* Layer Selection - Different layout for parallel vs others */}
                    {(currentCardType === 'parallel' || currentCardType === 'multi-parallel') ? (
                      <div>
                  <div style={{
                    display: 'flex',
                          alignItems: 'center',
                          gap: 8,
                          marginBottom: 8
                        }}>
                          <label style={{
                            fontSize: 14,
                            fontWeight: 600,
                            color: '#f8f8f8'
                          }}>
                            Select Spot Layer & Color
                          </label>
                          {currentCardType === 'multi-parallel' && (
                            <button
                              onClick={() => {
                                if (spotColorPairs.length < 3) {
                                setSpotColorPairs(prev => [...prev, { spot: '', color: undefined }]);
                                }
                              }}
                              disabled={!spotColorPairs[0]?.spot || spotColorPairs.length >= 3}
                              style={{
                                width: 24,
                                height: 24,
                                background: (!spotColorPairs[0]?.spot || spotColorPairs.length >= 3)
                                  ? 'rgba(156, 163, 175, 0.3)'
                                  : 'rgba(34, 197, 94, 0.2)',
                                border: '1px solid ' + ((!spotColorPairs[0]?.spot || spotColorPairs.length >= 3)
                                  ? 'rgba(156, 163, 175, 0.3)'
                                  : 'rgba(34, 197, 94, 0.4)'),
                                borderRadius: 6,
                                color: (!spotColorPairs[0]?.spot || spotColorPairs.length >= 3) ? '#6b7280' : '#86efac',
                                fontSize: 16,
                                cursor: (!spotColorPairs[0]?.spot || spotColorPairs.length >= 3) ? 'not-allowed' : 'pointer',
                          display: 'flex',
                          alignItems: 'center',
                                justifyContent: 'center',
                                transition: 'all 0.2s'
                              }}
                              onMouseOver={(e) => {
                                if (spotColorPairs[0]?.spot && spotColorPairs.length < 3) {
                                  e.currentTarget.style.background = 'rgba(34, 197, 94, 0.3)';
                                  e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.6)';
                                }
                              }}
                              onMouseOut={(e) => {
                                if (spotColorPairs[0]?.spot && spotColorPairs.length < 3) {
                                  e.currentTarget.style.background = 'rgba(34, 197, 94, 0.2)';
                                  e.currentTarget.style.borderColor = 'rgba(34, 197, 94, 0.4)';
                                }
                              }}
                              title={spotColorPairs.length >= 3 ? "Maximum 3 spots allowed" : "Add another spot/color pair"}
                            >
                              +
                            </button>
                          )}
                        </div>
                        
                        {/* Multiple Spot/Color Rows */}
                        <div style={{ display: 'flex', flexDirection: 'column', gap: 8 }}>
                          {spotColorPairs.map((pair, index) => {
                            const spotGroup = getColorVariants()[0]; // Always use first spot group
                            return (
                            <div key={index} style={{ display: 'flex', gap: 8, alignItems: 'flex-start' }}>
                              {/* Spot Layer Selection */}
                              <div style={{ flex: 1 }}>
                                {index === 0 && (
                                  <label style={{
                                    display: 'block',
                                    fontSize: 12,
                                    color: '#9ca3af',
                                    marginBottom: 4
                                  }}>
                                    Spot Layer
                                  </label>
                                )}
                                <select
                                  value={pair.spot || ''}
                                  onChange={(e) => {
                                    const newPairs = [...spotColorPairs];
                                    newPairs[index] = { ...newPairs[index], spot: e.target.value };
                                    setSpotColorPairs(newPairs);
                                  }}
                                  style={{
                                    width: '100%',
                        padding: '8px 12px',
                                    background: 'rgba(255, 255, 255, 0.08)',
                                    border: '1px solid rgba(255, 255, 255, 0.2)',
                                    borderRadius: 8,
                                    color: '#f8f8f8',
                                    fontSize: 14,
                                    marginTop: index > 0 ? '20px' : '0'
                                  }}
                                >
                                  <option value="" style={{ background: '#1f2937' }}>Select...</option>
                                  {getSpotLayers()
                                    .filter(layer => !spotColorPairs.some((p, i) => i !== index && p.spot === layer))
                                    .map(layer => (
                                      <option key={layer} value={layer} style={{ background: '#1f2937' }}>
                                        {layer}
                                      </option>
                                  ))}
                                </select>
                              </div>
                              
                              {/* Color Selection */}
                              <div style={{ flex: 1 }}>
                                {index === 0 && (
                                  <label style={{
                                    display: 'block',
                                    fontSize: 12,
                                    color: '#9ca3af',
                                    marginBottom: 4
                                  }}>
                                      Color
                                  </label>
                                )}
                                <select
                                  value={pair.color || ''}
                                  onChange={(e) => {
                                    if (e.target.value) {
                                      const newPairs = [...spotColorPairs];
                                                                            newPairs[index] = { 
                                        ...newPairs[index], 
                                        color: e.target.value
                                      };
                                      setSpotColorPairs(newPairs);
                            } else {
                                      const newPairs = [...spotColorPairs];
                                      newPairs[index] = { ...newPairs[index], color: undefined };
                                      setSpotColorPairs(newPairs);
                            }
                          }}
                                  disabled={!pair.spot}
                          style={{
                                    width: '100%',
                                    padding: '8px 12px',
                                    background: 'rgba(255, 255, 255, 0.08)',
                                    border: '1px solid rgba(255, 255, 255, 0.2)',
                                    borderRadius: 8,
                                    color: '#f8f8f8',
                                    fontSize: 14,
                                    marginTop: index > 0 ? '20px' : '0',
                                    opacity: !pair.spot ? 0.5 : 1
                                  }}
                                >
                                  <option value="" style={{ background: '#1f2937' }}>Select...</option>
                                  {spotGroup?.colors.map((colorLayer: any, idx: number) => (
                                    <option 
                                      key={idx} 
                                      value={colorLayer.name} 
                                      style={{ background: '#1f2937' }}
                                    >
                                      {colorLayer.name}
                                    </option>
                                  ))}
                                </select>
                              </div>
                              
                              {/* Remove Button */}
                              <button
                                onClick={() => {
                                  if (spotColorPairs.length > 1) {
                                    setSpotColorPairs(prev => prev.filter((_, i) => i !== index));
                                  }
                                }}
                                disabled={spotColorPairs.length === 1}
                                style={{
                                  width: 32,
                                  height: 32,
                                  background: spotColorPairs.length === 1 
                                    ? 'transparent' 
                                    : 'rgba(239, 68, 68, 0.1)',
                                  border: '1px solid ' + (spotColorPairs.length === 1 
                                    ? 'transparent' 
                                    : 'rgba(239, 68, 68, 0.2)'),
                                  borderRadius: 6,
                                  color: spotColorPairs.length === 1 ? 'transparent' : '#ef4444',
                                  fontSize: 16,
                                  cursor: spotColorPairs.length === 1 ? 'default' : 'pointer',
                                  display: 'flex',
                                  alignItems: 'center',
                                  justifyContent: 'center',
                                  transition: 'all 0.2s',
                                  marginTop: index > 0 ? '20px' : (index === 0 ? '20px' : '0')
                                }}
                                title={spotColorPairs.length === 1 ? '' : 'Remove'}
                              >
                                Ã—
                              </button>
                            </div>
                          );
                        })}
                        </div>
                  </div>
                ) : (
                      /* Regular Layer Selection for non-parallel types */
                      <div>
                        <label style={{
                          display: 'block',
                    fontSize: 14,
                          fontWeight: 600,
                          color: '#f8f8f8',
                          marginBottom: 8
                        }}>
                          Select Layer
                          {(() => {
                            const layersForType = getLayersByType(currentCardType);
                            return layersForType.length === 1 ? (
                              <span style={{ 
                                fontSize: 12, 
                                color: '#10b981', 
                                fontWeight: 400,
                                marginLeft: 8 
                              }}>
                                (auto-selected)
                              </span>
                            ) : null;
                          })()}
                        </label>
                        <select
                          value={currentConfig.layer || ''}
                          onChange={(e) => {
                            setCurrentConfig(prev => ({ ...prev, layer: e.target.value }));
                          }}
                          style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(255, 255, 255, 0.08)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: 8,
                            color: '#f8f8f8',
                            fontSize: 14
                          }}
                        >
                          <option value="" style={{ background: '#1f2937' }}>Select layer...</option>
                          {getLayersByType(currentCardType).map(layer => (
                            <option key={layer} value={layer} style={{ background: '#1f2937' }}>
                              {layer}
                            </option>
                          ))}
                        </select>
                  </div>
                )}

                    {/* Step 3: VFX Texture Selection */}
                            {(((currentCardType === 'parallel' || currentCardType === 'multi-parallel') && spotColorPairs.some(pair => pair.spot)) ||
        currentCardType === 'base') && getWpInvLayers().length > 0 && (
                      <div>
                  <label style={{
                    display: 'block',
                          fontSize: 14,
                    fontWeight: 600,
                    color: '#f8f8f8',
                          marginBottom: 8
                        }}>
                          Select VFX Texture
                          <span style={{ 
                            fontSize: 12, 
                            color: '#9ca3af', 
                            fontWeight: 400,
                            marginLeft: 8 
                          }}>
                            (optional)
                          </span>
                          {getWpInvLayers().length === 1 && (
                            <span style={{ 
                              fontSize: 12, 
                              color: '#9ca3af', 
                              fontWeight: 400,
                              marginLeft: 8 
                            }}>
                              - using {getWpInvLayers()[0]}
                            </span>
                          )}
                  </label>
                        <select
                          value={currentConfig.vfx || ''}
                          onChange={(e) => setCurrentConfig(prev => ({ ...prev, vfx: e.target.value }))}
                          style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(255, 255, 255, 0.08)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: 8,
                            color: '#f8f8f8',
                            fontSize: 14
                          }}
                        >
                          <option value="" style={{ background: '#1f2937' }}>Select VFX texture...</option>
                          {getVfxTextures().map((texture: string) => (
                            <option key={texture} value={texture} style={{ background: '#1f2937' }}>
                              {texture}
                            </option>
                          ))}
                        </select>
                        
                        {/* WP_INV Layer Selection - Show when VFX or chrome is enabled and wp_inv layers exist */}
                        {(currentConfig.vfx || currentConfig.chrome) && getWpInvLayers().length > 0 && (
                          <div style={{ marginTop: 12 }}>
                            <label style={{
                              display: 'block',
                              fontSize: 14,
                              fontWeight: 600,
                              color: '#f8f8f8',
                              marginBottom: 8
                            }}>
                              Select WP_INV Layer
                              {getWpInvLayers().length === 1 && (
                                <span style={{ 
                                  fontSize: 12, 
                                  color: '#10b981', 
                                  fontWeight: 400,
                                  marginLeft: 8 
                                }}>
                                  (auto-selected)
                                </span>
                              )}
                            </label>
                            <select
                              value={currentConfig.wp_inv_layer || ''}
                              onChange={(e) => setCurrentConfig(prev => ({ ...prev, wp_inv_layer: e.target.value }))}
                              disabled={getWpInvLayers().length === 1}
                              style={{
                                width: '100%',
                                padding: '8px 12px',
                                background: 'rgba(255, 255, 255, 0.08)',
                                border: '1px solid rgba(255, 255, 255, 0.2)',
                                borderRadius: 8,
                                color: '#f8f8f8',
                                fontSize: 14,
                                opacity: getWpInvLayers().length === 1 ? 0.7 : 1
                              }}
                            >
                              <option value="" style={{ background: '#1f2937' }}>
                                {getWpInvLayers().length === 1 ? getWpInvLayers()[0] : 'Select wp_inv layer...'}
                              </option>
                              {getWpInvLayers().length > 1 && getWpInvLayers().map(wpInvLayer => (
                                <option key={wpInvLayer} value={wpInvLayer} style={{ background: '#1f2937' }}>
                                  {wpInvLayer}
                                </option>
                              ))}
                            </select>
                          </div>
                        )}
                      </div>
                    )}

                    {/* Chrome Effect - Toggle for parallel/multi-parallel, dropdown for base */}
                    {(currentCardType === 'base' || currentCardType === 'parallel' || currentCardType === 'multi-parallel') && getWpInvLayers().length > 0 && (
                      <div>
                        {currentCardType === 'base' ? (
                          // Dropdown for base card type
                          <>
                            <label style={{
                              display: 'block',
                              fontSize: 14,
                              fontWeight: 600,
                              color: '#f8f8f8',
                              marginBottom: 8
                            }}>
                              Chrome Effect
                            </label>
                            <select
                              value={typeof currentConfig.chrome === 'string' ? currentConfig.chrome : ''}
                              onChange={(e) => {
                                const newChrome = e.target.value || false;
                                setCurrentConfig(prev => ({ 
                                  ...prev, 
                                  chrome: newChrome,
                                  // Enable oneOfOneWp by default when superfractor is selected
                                  oneOfOneWp: newChrome === 'superfractor' ? true : prev.oneOfOneWp
                                }));
                              }}
                              style={{
                                width: '100%',
                                padding: '8px 12px',
                                background: 'rgba(255, 255, 255, 0.08)',
                                border: '1px solid rgba(255, 255, 255, 0.2)',
                                borderRadius: 8,
                                color: '#f8f8f8',
                                fontSize: 14
                              }}
                            >
                              <option value="" style={{ background: '#1f2937' }}>None</option>
                              <option value="silver" style={{ background: '#1f2937' }}>Silver</option>
                              <option value="superfractor" style={{ background: '#1f2937' }}>Superfractor</option>
                            </select>
                            
                            {/* 10f1 wp checkbox - only show for superfractor */}
                            {currentConfig.chrome === 'superfractor' && (
                              <div style={{ marginTop: 12 }}>
                                <label style={{
                                  display: 'flex',
                                  alignItems: 'center',
                                  gap: 8,
                                  fontSize: 14,
                                  fontWeight: 600,
                                  color: '#f8f8f8',
                                  cursor: 'pointer'
                                }}>
                                  <input
                                    type="checkbox"
                                    checked={currentConfig.oneOfOneWp || false}
                                    onChange={(e) => setCurrentConfig(prev => ({ ...prev, oneOfOneWp: e.target.checked }))}
                                    style={{ width: 16, height: 16 }}
                                  />
                                  10f1 wp
                                </label>
                              </div>
                            )}
                          </>
                        ) : (
                          // Toggle for parallel/multi-parallel
                          <label style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: 8,
                            fontSize: 14,
                            fontWeight: 600,
                            color: '#f8f8f8',
                            cursor: 'pointer'
                          }}>
                            <input
                              type="checkbox"
                              checked={currentConfig.chrome === 'silver'}
                              onChange={(e) => setCurrentConfig(prev => ({ ...prev, chrome: e.target.checked ? 'silver' : false }))}
                              style={{ width: 16, height: 16 }}
                            />
                            Chrome Effect (Silver)
                          </label>
                        )}
                      </div>
                    )}

                    {/* Asset Name Input */}
                    {currentCardType && (
                      <div>
                        <label style={{
                          display: 'block',
                          fontSize: 14,
                          fontWeight: 600,
                          color: '#f8f8f8',
                          marginBottom: 8
                        }}>
                          Asset Name
                        </label>
                        <input
                          type="text"
                          value={currentConfig.name || ''}
                          onChange={(e) => setCurrentConfig(prev => ({ ...prev, name: e.target.value }))}
                          placeholder="Enter asset name..."
                          style={{
                            width: '100%',
                            padding: '8px 12px',
                            background: 'rgba(255, 255, 255, 0.08)',
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: 8,
                            color: '#f8f8f8',
                            fontSize: 14,
                            outline: 'none',
                            transition: 'border-color 0.2s',
                            boxSizing: 'border-box'
                          }}
                          onFocus={(e) => {
                            e.target.style.borderColor = 'rgba(59, 130, 246, 0.5)';
                          }}
                          onBlur={(e) => {
                            e.target.style.borderColor = 'rgba(255, 255, 255, 0.2)';
                          }}
                        />
                      </div>
                    )}

                    {/* Add Asset Button */}
                    <div>
                      {(() => {
                        // Validation logic for different card types
                        let canAdd = false;
                        let validationMessage = '';

                        if (!currentCardType) {
                          validationMessage = 'Select card type';
                        } else if (!currentConfig.name?.trim()) {
                          validationMessage = 'Enter asset name';
                        } else {
                          switch (currentCardType) {
                            case 'wp':
                            case 'back':
                            case 'base':
                            case 'wp-1of1':
                              if (!currentConfig.layer) {
                                validationMessage = 'Select layer';
                              } else {
                                canAdd = true;
                              }
                              break;
                            case 'parallel':
                            case 'multi-parallel':
                              const validPairs = spotColorPairs.filter(pair => pair.spot && pair.color);
                              if (validPairs.length === 0) {
                                validationMessage = 'Select at least one spot layer and color';
                              } else if (getWpInvLayers().length > 1 && !currentConfig.layer) {
                                // Only require wp_inv layer selection if there are multiple
                                validationMessage = 'Select wp_inv layer';
                              } else {
                                canAdd = true; // Have at least one valid spot/color pair
                              }
                              break;
                          }
                        }

                        return (
                          <>
                            <button
                              onClick={addAsset}
                              disabled={!canAdd || savingAsset}
                              style={{
                                padding: '12px 24px',
                                background: (!canAdd || savingAsset) ? 'rgba(156, 163, 175, 0.3)' : 'linear-gradient(135deg, #10b981, #059669)',
                                border: 'none',
                                borderRadius: 8,
                                color: 'white',
                                fontSize: 14,
                                fontWeight: 600,
                                cursor: (!canAdd || savingAsset) ? 'not-allowed' : 'pointer',
                                transition: 'all 0.2s',
                                opacity: (!canAdd || savingAsset) ? 0.6 : 1,
                                display: 'flex',
                                alignItems: 'center',
                                gap: 8
                              }}
                            >
                              {savingAsset && (
                                <div style={{
                                  width: 14,
                                  height: 14,
                                  border: '2px solid rgba(255, 255, 255, 0.3)',
                                  borderTop: '2px solid white',
                                  borderRadius: '50%',
                                  animation: 'spin 1s linear infinite'
                                }} />
                              )}
                              {savingAsset ? 'Saving...' : (editingAssetId ? 'Update Asset' : 'Add Asset')}
                            </button>
                            {editingAssetId && (
                              <button
                                onClick={resetCurrentConfig}
                              style={{
                                  padding: '12px 24px',
                                  background: 'rgba(156, 163, 175, 0.3)',
                                  border: 'none',
                                  borderRadius: 8,
                                  color: 'white',
                                  fontSize: 14,
                                  fontWeight: 600,
                                cursor: 'pointer',
                                  marginLeft: 8
                                }}
                              >
                                Cancel
                              </button>
                            )}
                            {validationMessage && (
                              <div style={{
                                fontSize: 12,
                                color: '#9ca3af',
                                marginTop: 8
                              }}>
                                {validationMessage}
                              </div>
                            )}
                          </>
                        );
                      })()}
                    </div>
                  </div>
                )}
              </div>

              {/* Right Side: Configured Assets List */}
              <div style={{
                flex: 1,
                minWidth: 600,
                background: 'rgba(255, 255, 255, 0.05)',
                borderRadius: 12,
                border: '1px solid rgba(255, 255, 255, 0.1)',
                padding: 20
              }}>
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                  marginBottom: 16
                }}>
                  <h3 style={{
                    fontSize: 18,
                    fontWeight: 600,
                    color: '#f8f8f8',
                    margin: 0
                  }}>
                    Assets to Generate ({configuredAssets.length})
                  </h3>
                  <button
                    onClick={() => document.getElementById('edr-pdf-input')?.click()}
                    disabled={savingAsset || creatingAssets || processingPdf}
                    style={{
                      padding: '8px 16px',
                      background: (savingAsset || creatingAssets || processingPdf)
                        ? 'rgba(156, 163, 175, 0.3)'
                        : 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
                      border: 'none',
                      borderRadius: 8,
                      color: 'white',
                      fontSize: 14,
                      fontWeight: 600,
                      cursor: (savingAsset || creatingAssets || processingPdf) ? 'not-allowed' : 'pointer',
                      transition: 'all 0.2s',
                      opacity: (savingAsset || creatingAssets || processingPdf) ? 0.6 : 1,
                      display: 'flex',
                      alignItems: 'center',
                      gap: 6
                    }}
                    onMouseEnter={(e) => {
                      if (!savingAsset && !creatingAssets && !processingPdf) {
                        e.currentTarget.style.transform = 'scale(1.02)';
                        e.currentTarget.style.boxShadow = '0 4px 12px rgba(139, 92, 246, 0.3)';
                      }
                    }}
                    onMouseLeave={(e) => {
                      if (!savingAsset && !creatingAssets && !processingPdf) {
                        e.currentTarget.style.transform = 'scale(1)';
                        e.currentTarget.style.boxShadow = 'none';
                      }
                    }}
                  >
                    {processingPdf ? (
                      <>
                        <div style={{
                          width: 14,
                          height: 14,
                          border: '2px solid rgba(255, 255, 255, 0.3)',
                          borderTop: '2px solid white',
                          borderRadius: '50%',
                          animation: 'spin 1s linear infinite'
                        }} />
                        Processing PDF...
                      </>
                    ) : (
                      <>
                        ðŸ“‹ Import from EDR
                      </>
                    )}
                  </button>
                  <input
                    id="edr-pdf-input"
                    type="file"
                    accept=".pdf"
                    style={{ display: 'none' }}
                    disabled={processingPdf}
                    onChange={handleEDRPdfUpload}
                  />
                  
                  {/* Upload Progress Indicator */}
                  {processingPdf && uploadProgress > 0 && (
                    <div style={{
                      marginTop: 12,
                      fontSize: 12,
                      color: '#9ca3af'
                    }}>
                      <div style={{
                        background: 'rgba(255, 255, 255, 0.1)',
                        borderRadius: 4,
                        height: 6,
                        marginBottom: 4,
                        overflow: 'hidden'
                      }}>
                        <div style={{
                          background: 'linear-gradient(90deg, #3b82f6, #8b5cf6)',
                          height: '100%',
                          width: `${uploadProgress}%`,
                          transition: 'width 0.3s ease'
                        }} />
                      </div>
                      <div style={{ textAlign: 'center' }}>
                        {uploadProgress < 10 && 'Getting upload instructions...'}
                        {uploadProgress >= 10 && uploadProgress < 90 && 'Uploading file...'}
                        {uploadProgress >= 90 && uploadProgress < 95 && 'Upload complete...'}
                        {uploadProgress >= 95 && 'Processing PDF...'}
                      </div>
                    </div>
                  )}
                </div>
                
                {configuredAssets.length > 0 ? (
                  <div style={{
                    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.05), rgba(147, 51, 234, 0.05))',
                    borderRadius: 12,
                    overflow: 'hidden',
                    marginBottom: 20,
                    border: '1px solid rgba(255, 255, 255, 0.1)',
                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
                  }}>
                                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 14 }}>
                      <thead>
                        <tr style={{ 
                          background: 'linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05))',
                          borderBottom: '2px solid rgba(255, 255, 255, 0.1)'
                        }}>
                                              <th style={{ padding: '10px 12px', textAlign: 'left', color: '#f8f8f8', fontSize: 13, fontWeight: 600, letterSpacing: '0.05em', maxWidth: '150px', width: '150px' }}>NAME</th>
                    <th style={{ padding: '10px 12px', textAlign: 'left', color: '#f8f8f8', fontSize: 13, fontWeight: 600, letterSpacing: '0.05em' }}>LAYERS</th>
                    <th style={{ padding: '10px 12px', textAlign: 'left', color: '#f8f8f8', fontSize: 13, fontWeight: 600, letterSpacing: '0.05em' }}>VFX</th>
                    <th 
                      style={{ 
                        padding: '10px 12px', 
                        textAlign: 'center', 
                        color: '#f8f8f8', 
                        fontSize: 13, 
                        fontWeight: 600, 
                        letterSpacing: '0.05em',
                        cursor: 'pointer',
                        userSelect: 'none',
                        transition: 'color 0.2s'
                      }}
                      onClick={async () => {
                        if (savingAsset || !jobData?.job_id) return;
                        
                        // Find all assets where chrome is currently off (false/falsy) but not superfractor
                        const assetsToUpdate = configuredAssets.filter(asset => 
                          !asset.chrome && 
                          asset.type !== 'wp' && 
                          asset.type !== 'back' && 
                          asset.type !== 'wp-1of1' &&
                          getWpInvLayers().length > 0
                        );
                        
                        if (assetsToUpdate.length === 0) {
                          console.log('ðŸ“‹ No assets need chrome update');
                          return;
                        }
                        
                        console.log(`ðŸ”§ Applying silver chrome to ${assetsToUpdate.length} assets`);
                        
                        setSavingAsset(true);
                        
                        try {
                          // Prepare bulk update payload matching the working cURL structure
                          const bulkAssets = assetsToUpdate.map(asset => ({
                            name: asset.name,
                            type: asset.type,
                            layer: asset.layer,
                            config: {
                              ...(asset.spot && { spot: asset.spot }),
                              ...(asset.color && { color: getColorRgbByName(asset.color) }),
                              ...(asset.vfx && { vfx: asset.vfx }),
                              chrome: 'silver', // Apply silver chrome
                              ...(asset.wp_inv_layer && { wp_inv_layer: asset.wp_inv_layer }),
                              // Handle spot_color_pairs for parallel types
                              ...(asset.spotColorPairs && asset.spotColorPairs.length > 0 && {
                                spot_color_pairs: asset.spotColorPairs.map(pair => ({
                                  spot: pair.spot,
                                  color: getColorRgbByName(pair.color || '')
                                }))
                              })
                            }
                          }));
                          
                          console.log('ðŸ“¦ Bulk update payload:', bulkAssets);
                          
                          // Make single bulk update API call
                          const response = await contentPipelineApi.bulkUpdateAssets(jobData.job_id, bulkAssets);
                          
                          if (response.success) {
                            console.log(`âœ… Successfully applied chrome to ${assetsToUpdate.length} assets`);
                            
                            // Update job data with response
                            if (response.job && onJobDataUpdate) {
                              console.log('ðŸ”„ Updating job data from bulk chrome response');
                              onJobDataUpdate(response.job);
                            } else if (onJobDataUpdate) {
                              console.log('ðŸ”„ Triggering job data refresh after bulk chrome update');
                              onJobDataUpdate({ _forceRefetch: true, job_id: jobData.job_id });
                            }
                            
                            alert(`âœ… Successfully applied silver chrome to ${assetsToUpdate.length} assets!`);
                          } else {
                            console.error('âŒ Bulk chrome update failed:', response);
                            alert(`Failed to apply chrome: ${response.message || 'Unknown error'}`);
                          }
                          
                        } catch (error) {
                          console.error('âŒ Error applying bulk chrome update:', error);
                          alert(`Failed to apply chrome: ${error instanceof Error ? error.message : 'Unknown error'}`);
                        } finally {
                          setSavingAsset(false);
                        }
                      }}
                      onMouseEnter={(e) => {
                        if (!savingAsset) {
                          e.currentTarget.style.color = '#c084fc';
                        }
                      }}
                      onMouseLeave={(e) => {
                        if (!savingAsset) {
                          e.currentTarget.style.color = '#f8f8f8';
                        }
                      }}
                      title="Click to apply silver chrome to all assets where chrome is off"
                    >
                      CHROME
                    </th>
                    <th style={{ padding: '10px 12px', textAlign: 'center', color: '#f8f8f8', fontSize: 13, fontWeight: 600, letterSpacing: '0.05em' }}>ACTIONS</th>
                        </tr>
                      </thead>
                      <tbody>
                        {configuredAssets
                          .sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()))
                          .map((asset, index) => {
                          return (
                            <tr key={asset.id} style={{ 
                              borderBottom: index < configuredAssets.length - 1 ? '1px solid rgba(255, 255, 255, 0.05)' : 'none',
                              transition: 'background 0.2s',
                              background: index % 2 === 0 ? 'transparent' : 'rgba(255, 255, 255, 0.02)'
                            }}
                            onMouseOver={(e) => e.currentTarget.style.background = 'rgba(255, 255, 255, 0.05)'}
                            onMouseOut={(e) => e.currentTarget.style.background = index % 2 === 0 ? 'transparent' : 'rgba(255, 255, 255, 0.02)'}
                            >
                              <td style={{ 
                                padding: '10px 12px', 
                                color: '#f8f8f8', 
                                fontSize: 13,
                                fontWeight: 500,
                                maxWidth: '150px',
                                width: '150px'
                              }}>
                                <div style={{
                                  display: 'flex',
                                  flexDirection: 'column',
                                  gap: 4
                                }}>
                                  <span style={{
                                    color: '#f8f8f8',
                                    fontSize: 13,
                                    fontWeight: 600,
                                    overflow: 'hidden',
                                    textOverflow: 'ellipsis',
                                    whiteSpace: 'nowrap',
                                    display: 'block'
                                  }}>
                                    {asset.name}
                                  </span>
                                  <span style={{
                                    background: asset.type === 'wp' ? 'rgba(34, 197, 94, 0.2)' : 
                                               asset.type === 'back' ? 'rgba(168, 85, 247, 0.2)' :
                                               asset.type === 'base' ? 'rgba(59, 130, 246, 0.2)' :
                                               asset.type === 'wp-1of1' ? 'rgba(245, 158, 11, 0.2)' :
                                               'rgba(236, 72, 153, 0.2)',
                                    color: asset.type === 'wp' ? '#86efac' : 
                                           asset.type === 'back' ? '#c084fc' :
                                           asset.type === 'base' ? '#93c5fd' :
                                           asset.type === 'wp-1of1' ? '#fbbf24' :
                                           '#f9a8d4',
                                    padding: '2px 6px',
                                    borderRadius: 3,
                                    fontSize: 10,
                                    fontWeight: 600,
                                    letterSpacing: '0.02em',
                                    alignSelf: 'flex-start'
                                  }}>
                                    {asset.type === 'base' ? 'BASE' : asset.type === 'parallel' ? 'PARALLEL' : asset.type === 'multi-parallel' ? 'MULTI-PARALLEL' : asset.type === 'wp-1of1' ? 'WP-1OF1' : asset.type.toUpperCase()}
                                  </span>
                                </div>
                              </td>
                              <td style={{ padding: '10px 12px', color: '#e5e7eb', fontSize: 13, textAlign: 'center' }}>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: 4, alignItems: 'center' }}>
                                  {/* Show asset layer first */}
                                  {asset.layer && (
                                    <>
                                      <span style={{
                                        fontSize: 12,
                                        fontFamily: 'monospace',
                                        color: '#e5e7eb'
                                      }}>
                                        {asset.layer}
                                      </span>
                                    </>
                                  )}
                                  
                                  {/* Show spot values from spot_color_pairs */}
                                  {asset.spotColorPairs && asset.spotColorPairs.length > 0 && (
                                    <div>
                                      {asset.spotColorPairs.map((pair, idx) => (
                                        <div key={idx} style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 2, justifyContent: 'center' }}>
                                          <span style={{
                                            fontSize: 12,
                                            fontFamily: 'monospace',
                                            color: '#e5e7eb'
                                          }}>
                                            {pair.spot}
                                          </span>
                                          {pair.color && (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                                              <span style={{
                                                width: 8,
                                                height: 8,
                                                borderRadius: '50%',
                                                background: pair.color?.startsWith('R') ? getColorHexByRgb(pair.color) : getColorHexByName(pair.color || ''),
                                                display: 'inline-block',
                                                border: '1px solid rgba(255, 255, 255, 0.2)'
                                              }} />
                                              <span style={{ fontSize: 12, color: '#d1d5db' }}>
                                                {pair.color?.startsWith('R') ? getColorDisplayNameByRgb(pair.color) : HARDCODED_COLORS.find(c => c.name === pair.color)?.name || pair.color}
                                              </span>
                                            </div>
                                          )}
                                        </div>
                                      ))}
                                    </div>
                                  )}
                                  
                                  {/* Legacy single spot/color display */}
                                  {asset.spot && (!asset.spotColorPairs || asset.spotColorPairs.length === 0) && (
                                    <div>
                                      <div style={{ display: 'flex', alignItems: 'center', gap: 6, justifyContent: 'center' }}>
                                        <span style={{
                                          fontSize: 12,
                                          fontFamily: 'monospace',
                                          color: '#e5e7eb'
                                        }}>
                                          {asset.spot}
                                        </span>
                                        {asset.color && (
                                          <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                                            <span style={{
                                              width: 8,
                                              height: 8,
                                              borderRadius: '50%',
                                              background: asset.color?.startsWith('R') ? getColorHexByRgb(asset.color) : getColorHexByName(asset.color || ''),
                                              display: 'inline-block',
                                              border: '1px solid rgba(255, 255, 255, 0.2)'
                                            }} />
                                            <span style={{ fontSize: 12, color: '#d1d5db' }}>
                                              {asset.color?.startsWith('R') ? getColorDisplayNameByRgb(asset.color) : HARDCODED_COLORS.find(c => c.name === asset.color)?.name || asset.color}
                                            </span>
                                          </div>
                                        )}
                                      </div>
                                    </div>
                                  )}
                                  
                                  {/* Fallback: Show dash for empty cases */}
                                  {!asset.layer && (!asset.spotColorPairs || asset.spotColorPairs.length === 0) && !asset.spot && (
                                    <span style={{ color: '#6b7280' }}>â€”</span>
                                  )}
                                  

                                </div>
                              </td>
                              <td style={{ padding: '10px 12px', color: '#e5e7eb', fontSize: 13 }}>
                                {asset.vfx ? (
                                  <span style={{
                                    background: 'rgba(147, 51, 234, 0.1)',
                                    color: '#c084fc',
                                    padding: '2px 6px',
                                    borderRadius: 4,
                                    fontSize: 12
                                  }}>
                                    {asset.vfx}
                                  </span>
                                ) : (
                                  <span style={{ color: '#6b7280' }}>â€”</span>
                                )}
                              </td>
                              <td style={{ padding: '10px 12px', textAlign: 'center' }}>
                                {asset.type === 'wp' || asset.type === 'back' || asset.type === 'wp-1of1' || getWpInvLayers().length === 0 ? (
                                  <span style={{ color: '#6b7280' }}>â€”</span>
                                ) : (
                                  <span style={{
                                    display: 'inline-flex',
                                    alignItems: 'center',
                                    gap: 3,
                                    background: asset.chrome ? 'rgba(34, 197, 94, 0.2)' : 'rgba(156, 163, 175, 0.2)',
                                    color: asset.chrome ? '#86efac' : '#9ca3af',
                                    padding: '3px 8px',
                                    borderRadius: 12,
                                    fontSize: 12,
                                    fontWeight: 600
                                  }}>
                                    <span style={{
                                      width: 5,
                                      height: 5,
                                      borderRadius: '50%',
                                      background: asset.chrome ? '#86efac' : '#6b7280'
                                    }} />
                                    {asset.chrome ? (typeof asset.chrome === 'string' ? asset.chrome.toUpperCase() : 'ON') : 'OFF'}
                                  </span>
                                )}
                              </td>
                              <td style={{ padding: '10px 12px', textAlign: 'center' }}>
                                <div style={{ display: 'flex', gap: 6, justifyContent: 'center' }}>
                                  <button
                                    onClick={() => editAsset(asset)}
                                    disabled={savingAsset}
                                    style={{
                                      width: 26,
                                      height: 26,
                                      background: savingAsset ? 'rgba(156, 163, 175, 0.1)' : 'rgba(59, 130, 246, 0.1)',
                                      border: '1px solid ' + (savingAsset ? 'rgba(156, 163, 175, 0.2)' : 'rgba(59, 130, 246, 0.2)'),
                                      borderRadius: 6,
                                      color: savingAsset ? '#9ca3af' : '#60a5fa',
                                      fontSize: 14,
                                      cursor: savingAsset ? 'not-allowed' : 'pointer',
                                      display: 'inline-flex',
                                      alignItems: 'center',
                                      justifyContent: 'center',
                                      transition: 'all 0.2s',
                                      position: 'relative',
                                      overflow: 'hidden',
                                      opacity: savingAsset ? 0.5 : 1
                                    }}
                                    onMouseOver={(e) => {
                                      if (!savingAsset) {
                                        e.currentTarget.style.background = 'rgba(59, 130, 246, 0.2)';
                                        e.currentTarget.style.borderColor = 'rgba(59, 130, 246, 0.4)';
                                        e.currentTarget.style.transform = 'scale(1.05)';
                                      }
                                    }}
                                    onMouseOut={(e) => {
                                      if (!savingAsset) {
                                        e.currentTarget.style.background = 'rgba(59, 130, 246, 0.1)';
                                        e.currentTarget.style.borderColor = 'rgba(59, 130, 246, 0.2)';
                                        e.currentTarget.style.transform = 'scale(1)';
                                      }
                                    }}
                                    title={savingAsset ? "Saving..." : "Edit asset"}
                                  >
                                    âœï¸
                                  </button>
                                  <button
                                    onClick={() => removeAsset(asset.id)}
                                    disabled={savingAsset}
                                    style={{
                                      width: 26,
                                      height: 26,
                                      background: savingAsset ? 'rgba(156, 163, 175, 0.1)' : 'rgba(239, 68, 68, 0.1)',
                                      border: '1px solid ' + (savingAsset ? 'rgba(156, 163, 175, 0.2)' : 'rgba(239, 68, 68, 0.2)'),
                                      borderRadius: 6,
                                      color: savingAsset ? '#9ca3af' : '#ef4444',
                                      fontSize: 14,
                                      cursor: savingAsset ? 'not-allowed' : 'pointer',
                                      display: 'inline-flex',
                                      alignItems: 'center',
                                      justifyContent: 'center',
                                      transition: 'all 0.2s',
                                      opacity: savingAsset ? 0.5 : 1
                                    }}
                                    onMouseOver={(e) => {
                                      if (!savingAsset) {
                                        e.currentTarget.style.background = 'rgba(239, 68, 68, 0.2)';
                                        e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.4)';
                                        e.currentTarget.style.transform = 'scale(1.05)';
                                      }
                                    }}
                                    onMouseOut={(e) => {
                                      if (!savingAsset) {
                                        e.currentTarget.style.background = 'rgba(239, 68, 68, 0.1)';
                                        e.currentTarget.style.borderColor = 'rgba(239, 68, 68, 0.2)';
                                        e.currentTarget.style.transform = 'scale(1)';
                                      }
                                    }}
                                    title={savingAsset ? "Saving..." : "Remove asset"}
                                  >
                                    ðŸ—‘ï¸
                                  </button>
                                </div>
                              </td>
                            </tr>
                        );
                      })}
                      </tbody>
                    </table>
                    </div>
                  ) : (
                    <div style={{
                    textAlign: 'center',
                    padding: '48px 24px',
                      color: '#9ca3af',
                    fontSize: 14,
                    background: 'linear-gradient(135deg, rgba(59, 130, 246, 0.03), rgba(147, 51, 234, 0.03))',
                    borderRadius: 12,
                    border: '1px dashed rgba(255, 255, 255, 0.1)'
                  }}>
                    <div style={{
                      width: 48,
                      height: 48,
                      background: 'rgba(255, 255, 255, 0.05)',
                      borderRadius: '50%',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      margin: '0 auto 16px',
                      fontSize: 24
                    }}>
                      ðŸ“‹
                    </div>
                    <div style={{ fontStyle: 'italic', marginBottom: 8 }}>
                      No assets configured yet
                    </div>
                    <div style={{ color: '#6b7280', fontSize: 13 }}>
                      Use the form on the left to add assets
                    </div>
                </div>
              )}

                {/* Generate All Assets Button */}
                {configuredAssets.length > 0 && (
                <button
                  onClick={createAssets}
                  disabled={creatingAssets || !canCreateAssets}
                  style={{
                      width: '100%',
                    padding: '16px 32px',
                    background: creatingAssets 
                      ? 'rgba(156, 163, 175, 0.5)' 
                      : 'linear-gradient(135deg, #10b981, #059669)',
                    border: 'none',
                    borderRadius: 12,
                    color: 'white',
                    fontSize: 16,
                    fontWeight: 600,
                      cursor: creatingAssets ? 'not-allowed' : 'pointer',
                    transition: 'all 0.2s',
                      boxShadow: creatingAssets ? 'none' : '0 8px 24px rgba(16, 185, 129, 0.3)'
                  }}
                >
                  {creatingAssets ? (
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 8 }}>
                      <div style={{
                        width: 16,
                        height: 16,
                        border: '2px solid rgba(255, 255, 255, 0.3)',
                        borderTop: '2px solid white',
                        borderRadius: '50%',
                        animation: 'spin 1s linear infinite'
                      }} />
                        Creating Assets...
                    </div>
                  ) : (
                      mergedJobData?.job_status?.toLowerCase() === 'generation-failed' 
                        ? `ðŸ”„ Retry Asset Generation (${configuredAssets.length})`
                        : `ðŸŽ¨ Generate All Assets (${configuredAssets.length})`
                  )}
                </button>
                )}
              </div>
            </div>
          )}
        </div>
      </div>
    </>
  );
}; 